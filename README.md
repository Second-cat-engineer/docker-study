## Docker (курс php3)
***

Возможность процесс запустить изолировано:
- Процесс думает что он один единственный в ОС, т.е. он другие процессы не видит;
- Процесс думает что он запущен от root и  может делать все что угодно;
- Но чтобы он не делал все что угодно, он запускается в виртуальной файловой системе (те, которые содержаться в 
специальном образе Docker)
- Не только изоляция файловой системы, но и сетевая изоляция (необходимо пробрасывать порты).

Dockerfile - это файл, с инструкциями по сборке образа.
Образы можно наследовать друг от друга, т.е. можно сказать "Возьми официальный образ php и кое-что в нем сделай".

~~~dockerfile
FROM php:8.0-fpm                                   // Что взять 
WORKDIR /app                                       // Та папка, которую процесс будет считать основной
COPY . /app                                        // Все содержимое текущей папки будет скопировано в папку app
RUN ["php", "-S", "0.0.0.0:8080", "-t", "/app"]    // Какой процесс запустить
~~~
Отличие RUN от CMD: первый собирает и сразу запускает, второй ждет запуска

Далее в консоли:
> docker build -t my-php .



По умолчанию процесс выполняющийся в контейнере, к сети не имеет никакого доступа. Для того чтобы он имел доступ к сети
необходимо открыть порт. При запуске указать маппинг портов

> docker build -t my-php .
> docker run -p 8080:8080 my-app


В чем преимущество такого подхода:
- Описали окружение в виде конфигурации. Любой кто возьмет Dockerfile и повторит у себя получит ровно такое же
окружение;
- т.к. это просто файл, то получаем управление версиями, т.е. переход с 7.4 на 8.0 видна, кто, когда, и зачем, и 
бесконтрольно она не пройдет.


Если в проект внести изменения, то эти изменения в docker не попадут, нужно заново собирать образ, поэтому чистый докер 
не особо интересен.


### Docker compose

Dockerfile - файл конфигурации сборки одного контейнера
Docker compose - конфигурация сборки нескольких контейнеров в некий оркестр, когда они все работают согласованно


Смотри директорию php-3-lesson-1-composer
~~~yaml
version: "3"

services:

  php:
    build:
      context: .build/php
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    volumes:
      - ./:/app
~~~

В консоли запустить команду:
> docker-compose build

Запустит весь оркестр контейнеров:
> docker-compose up -d --build
- -d говорит что консоль не привязывай, просто запусти
- --build - сразу видны изменения 

Выключить всю систему контейнеров:
> docker-compose down

Имя сервиса можно использовать для обращения к контейнеру "docker compose выполни в контейнере, который ты называешь 
php команду bash":
> docker-compose exec php bash





***
## Установка composer внутри контейнера

~~~dockerfile
FROM php:8.0-fpm
WORKDIR /app
RUN apt install curl
RUN curl -s https://getcomposer.org/installer | php && mv composer.phar /usr/local/bin/composer
CMD ["php", "-S", "0.0.0.0:8080", "-t", "/app"]
~~~


Для запуска композера из контейнера необходим zip, для его установки в контейнер
~~~dockerfile
FROM php:8.0-fpm
WORKDIR /app
RUN apt-get update
RUN apt install -y curl zip unzip
RUN curl -s https://getcomposer.org/installer | php && mv composer.phar /usr/local/bin/composer
CMD ["php", "-S", "0.0.0.0:8080", "-t", "/app"]
~~~

И для запуска композера внутри
> docker-compose exec php composer install


***

## Сценарии сборки приложения
### Makefile
Это способ в одном файле записать некие именованные сценарии, и потом их по имени вызывать 

~~~yaml
up:
  docker-compose up -d --build
down:
  docker-compose down
~~~







